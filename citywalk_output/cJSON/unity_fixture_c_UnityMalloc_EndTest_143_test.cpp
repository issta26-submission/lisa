/*
This file provides a focused C++11 test suite for the focal UnityMalloc_EndTest() function
contained in unity_fixture.c. It uses the Unity fixture framework (via unity_fixture.h)
to structure tests, without GTest. The tests exercise the memory-leak detection path by
manually invoking UnityMalloc_StartTest, allocating memory with unity_malloc, and then
calling UnityMalloc_EndTest to observe behavior.

Notes:
- Test 1 (NoLeak): Allocate and free a block, then call EndTest. Expect no failure.
- Test 2 (Leak): Allocate a block and do not free. EndTest should flag a leak (test failure).

The tests are written as a Unity fixture test group so they can be compiled into the same
test binary as the Unity fixture runner (unity_fixture.c). The main() delegates to
UnityMain(...) with a RunAllTests() function registered via the Unity fixture framework.
*/

#include <unity_internals.h>
#include <cstddef>
#include <stdlib.h>
#include <string.h>
#include <unity_fixture.h>


// Bring in the Unity fixture API (C linkage assumed for Unity symbols)
extern "C" {
}

// Prototypes for Unity memory wrappers/controls (C linkage)
extern "C" {
    void* unity_malloc(size_t size);
    void  unity_free(void* mem);
    void  UnityMalloc_StartTest(void);
    void  UnityMalloc_EndTest(void);
}

// Since we are in C++, ensure we use the Unity fixture test group style
TEST_GROUP(UnityMallocEndTest);

TEST_SETUP(UnityMallocEndTest)
{
    // Ensure a clean test-start state for each test
    UnityMalloc_StartTest();
}

TEST_TEAR_DOWN(UnityMallocEndTest)
{
    // No special teardown required; Unity fixture handles per-test state
}

/*
 Test: NoLeak
 Purpose: Validate that EndTest does not flag a failure when allocations are properly freed.
 Steps:
 - Start a test with UnityMalloc_StartTest (via setup)
 - Allocate a block with unity_malloc
 - Free the block with unity_free
 - Call UnityMalloc_EndTest to finish the test
 Expected: No UnityTestFail should be triggered; the test should pass.
*/
TEST(UnityMallocEndTest, NoLeak)
{
    void* p = unity_malloc(64);
    // Use the allocated memory to avoid compiler optimizations removing it
    (void)p;
    unity_free(p);

    // EndTest should NOT detect a leak
    UnityMalloc_EndTest();

    // If EndTest had detected a leak, UnityTest framework would have failed this test.
    // Reaching this point means the test passed for the "NoLeak" scenario.
}

/*
 Test: Leak
 Purpose: Verify that EndTest detects a leak when memory is allocated and not freed.
 Steps:
 - Start a test with UnityMalloc_StartTest (via setup)
 - Allocate a block with unity_malloc and intentionally do not free it
 - Call UnityMalloc_EndTest to finish the test (this should trigger a failure)
 Expected: The test is reported as failed due to the leak.
 Note: The Unity test harness may abort the test on failure; this is the intended behavior to
 demonstrate leak detection by UnityMalloc_EndTest.
*/
TEST(UnityMallocEndTest, Leak)
{
    void* p = unity_malloc(64);
    (void)p;
    // Intentionally do not free to simulate a memory leak
    UnityMalloc_EndTest();
    // If EndTest detects the leak, this test will fail as part of the Unity framework.
}

// Runner that registers all tests in this group
static void RunAllTests(void)
{
    // Note: Function names are generated by the UNITY fixture macros.
    RUN_TEST(UnityMallocEndTest_NoLeak);
    RUN_TEST(UnityMallocEndTest_Leak);
}

// Main entrypoint delegating to Unity's test runner
int main(int argc, const char* argv[])
{
    // The Unity fixture provides UnityMain in the linked unity_fixture.c
    return UnityMain(argc, argv, RunAllTests);
}