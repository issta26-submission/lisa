/*
  Unit test suite for the focal method cre2_full_match (as generated by
  DEFINE_MATCH_ZSTRING_FUN in cre2.cpp).

  Approach:
  - Use a lightweight, self-contained test runner (no GoogleTest).
  - Exercise cre2_full_match via a few representative scenarios:
    - Simple literal full match.
    - Simple literal that does not fully match (negative case).
    - Regex-based full match (pattern with wildcard) to ensure behavior with non-literal patterns.
    - Invalid pattern handling (cre2_new returns NULL) to cover error path.
  - Ensure we only rely on standard library and the provided CRE2 C API (via cre2.h).
  - Each test is annotated with comments explaining intent and expected outcomes.
  - Results are printed; the program returns non-zero if any test fails.

  Notes:
  - The CRE2 C interface used here is inferred from the provided snippet and common CRE2 wrappers:
    - cre2_new(const char* pattern, int pattern_len, const cre2_options_t* opt) -> cre2_regexp_t*
    - cre2_delete(cre2_regexp_t* re)
    - cre2_string_t is a struct { const char* data; int length; }
    - cre2_full_match(const cre2_regexp_t* re, const char* text, int text_len, cre2_string_t* match, int nmatch) -> int
  - If your project uses a slightly different prototype for cre2_full_match, adjust the test calls
    accordingly. The test is designed to be easily adaptable to the most common CRE2 C API shapes.

  Compile command example (adjust as needed by your build system):
  g++ -std=c++11 -I<path_to_cre2_headers> test_cre2_full_match.cpp -L<path_to_cre2_lib> -lcre2 -o test_cre2_full_match
*/

#include <cre2.h>
#include <cstring>
#include <re2/re2.h>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <cstdio>
#include <re2/set.h>


// Simple test harness counters
static int g_total = 0;
static int g_pass = 0;
static int g_fail = 0;

// Utility to print test result and update counters
static void report(bool ok, const char* test_name) {
    g_total++;
    if (ok) {
        g_pass++;
        std::cout << "[PASS] " << test_name << std::endl;
    } else {
        g_fail++;
        std::cout << "[FAIL] " << test_name << std::endl;
    }
}

// Test 1: Simple literal full match
// Pattern: "abc"  Text: "abc"  Expect full match (ret == 1) and match length == 3
static bool test_cre2_full_match_literal_basic() {
    const char* pattern = "abc";
    int pattern_len = 3;

    cre2_regexp_t *re = cre2_new(pattern, pattern_len, NULL);
    if (!re) {
        // If the pattern couldn't be compiled, this is a test setup failure.
        return false;
    }

    cre2_string_t match{nullptr, 0};
    const char* text = "abc";
    int text_len = 3;

    int ret = cre2_full_match(re, text, text_len, &match, 1);
    bool ok = (ret == 1) && (match.data != nullptr) && (match.length == text_len);

    // Cleanup
    cre2_delete(re);

    return ok;
}

// Test 2: Simple literal that should not fully match
// Pattern: "abc"  Text: "abcd"  Expect no full match (ret == 0)
static bool test_cre2_full_match_literal_negative() {
    const char* pattern = "abc";
    int pattern_len = 3;

    cre2_regexp_t *re = cre2_new(pattern, pattern_len, NULL);
    if (!re) {
        return false;
    }

    cre2_string_t match{nullptr, 0};
    const char* text = "abcd";
    int text_len = 4;

    int ret = cre2_full_match(re, text, text_len, &match, 1);
    bool ok = (ret == 0);

    cre2_delete(re);
    return ok;
}

// Test 3: Regex-style full match
// Pattern: "a.*"  Text: "abcdef"  Expect full match (ret == 1) and match length == 6
static bool test_cre2_full_match_regex_wildcard() {
    const char* pattern = "a.*";
    int pattern_len = 3;

    cre2_regexp_t *re = cre2_new(pattern, pattern_len, NULL);
    if (!re) {
        return false;
    }

    cre2_string_t match{nullptr, 0};
    const char* text = "abcdef";
    int text_len = 6;

    int ret = cre2_full_match(re, text, text_len, &match, 1);
    bool ok = (ret == 1) && (match.data != nullptr) && (match.length == text_len);

    cre2_delete(re);
    return ok;
}

// Test 4: Invalid pattern should return NULL from cre2_new and be handled gracefully
static bool test_cre2_full_match_invalid_pattern() {
    // Intentionally invalid regex
    const char* bad_pattern = "("; // incomplete group
    int pattern_len = 1;

    cre2_regexp_t *re = cre2_new(bad_pattern, pattern_len, NULL);
    // cre2_new should return NULL on error
    bool ok = (re == NULL);

    // No need to call cre2_full_match; just ensure failure to compile is handled gracefully
    // (No crash should occur)
    return ok;
}

// Entry point
int main() {
    std::cout << "Starting test suite for cre2_full_match (from cre2.cpp)" << std::endl;

    report(test_cre2_full_match_literal_basic(), "test_cre2_full_match_literal_basic");
    report(test_cre2_full_match_literal_negative(), "test_cre2_full_match_literal_negative");
    report(test_cre2_full_match_regex_wildcard(), "test_cre2_full_match_regex_wildcard");
    report(test_cre2_full_match_invalid_pattern(), "test_cre2_full_match_invalid_pattern");

    std::cout << "\nTest Summary: " << g_pass << " passed, "
              << g_fail << " failed, "
              << g_total << " total." << std::endl;

    // Return non-zero if any test failed
    return (g_fail == 0) ? 0 : 1;
}