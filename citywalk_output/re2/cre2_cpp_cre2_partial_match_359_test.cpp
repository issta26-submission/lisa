// Unit test suite for cre2_partial_match (wrapper generated by DEFINE_MATCH_ZSTRING_FUN)
// This test assumes the following signature based on typical CRE2 wrapper patterns:
//
// int cre2_partial_match(const char* pattern, cre2_string_t* text_and_target, cre2_string_t* match, int nmatch)
//
// - text_and_target is mutated to reference the text after the matching portion on success.
// - match holds the captured matching portion (of length given by match.length).
// - Returns: 1 on success (a match), 0 if no match, -1 on error.
//
// Note: This is a best-effort test based on the FOCAL_METHOD snippet and accompanying
// class declarations. The exact header/prototypes come from CRE2's C API wrappers.

#include <cre2.h>
#include <cstring>
#include <re2/re2.h>
#include <cstdlib>
#include <string>
#include <vector>
#include <iostream>
#include <cstdio>
#include <re2/set.h>


// Include the CRE2 C API header. Path may vary in your environment.
// If your build system uses <cre2.h>, keep that. If it uses "cre2.h", adjust accordingly.

// Simple test harness (no GTest). Use non-terminating assertions to maximize code coverage.

static int g_failures = 0;

// Assertion helpers
#define EXPECT_TRUE(cond) do { \
    if(!(cond)) { \
        std::cerr << "[TEST FAIL] " << __FILE__ << ":" << __LINE__ << " - expected true but got false: " #cond "\n"; \
        ++g_failures; \
    } \
} while(0)

#define EXPECT_EQ(a,b) do { \
    if(!((a) == (b))) { \
        std::cerr << "[TEST FAIL] " << __FILE__ << ":" << __LINE__ << " - expected " #a " == " #b " (" << (a) << " vs " << (b) << ")\n"; \
        ++g_failures; \
    } \
} while(0)

#define EXPECT_STR_EQ(p, len, s) do { \
    std::string _tmp((p), (len)); \
    if(_tmp != (s)) { \
        std::cerr << "[TEST FAIL] " << __FILE__ << ":" << __LINE__ << " - expected string equal to \"" << (s) \
                  << "\" but got \"" << _tmp << "\"\n"; \
        ++g_failures; \
    } \
} while(0)


// Test 1: Basic positive match - pattern at the start, input should be mutated to remainder.
// Expect: return 1, text length reduced by matched portion, match contains the matched text.
void test_cre2_partial_match_basic()
{
    // Prepare input: "abcdef" with mutable buffer
    char buf[64] = "abcdef";
    cre2_string_t text;
    text.data = buf;
    text.length = 6;

    cre2_string_t match;
    int ret = cre2_partial_match("abc", &text, &match, 1);

    EXPECT_EQ(ret, 1);
    // Remaining input should be "def" (length 3)
    EXPECT_EQ(text.length, 3);
    EXPECT_STR_EQ(text.data, text.length, "def");
    // Capture should be "abc" (length 3)
    EXPECT_EQ(match.length, 3);
    EXPECT_STR_EQ(match.data, match.length, "abc");
}

// Test 2: No match scenario - pattern not present at the start of input.
// Expect: return 0 and input should remain unchanged.
void test_cre2_partial_match_no_match()
{
    // Prepare input: "abcdef" with mutable buffer
    char buf[64] = "abcdef";
    cre2_string_t text;
    text.data = buf;
    text.length = 6;

    cre2_string_t match;
    int ret = cre2_partial_match("xyz", &text, &match, 1);

    EXPECT_EQ(ret, 0);
    // Input should be unchanged
    EXPECT_EQ(text.length, 6);
    EXPECT_STR_EQ(text.data, text.length, "abcdef");
    // Match should be untouched or unchanged; length could be zero if no capture;
    // We only assert that the match data length is non-negative.
    EXPECT_TRUE(match.length >= 0);
}

// Test 3: Sequential mutation - after first successful match, test that a subsequent
// match can operate on the mutated input.
void test_cre2_partial_match_sequential_mutation()
{
    // First step: match "ab" in "abcd" -> remainder "cd"
    char buf1[64] = "abcd";
    cre2_string_t text1;
    text1.data = buf1;
    text1.length = 4;
    cre2_string_t match1;
    int ret1 = cre2_partial_match("ab", &text1, &match1, 1);
    EXPECT_EQ(ret1, 1);
    EXPECT_EQ(text1.length, 2); // remaining "cd"
    EXPECT_STR_EQ(text1.data, text1.length, "cd");
    EXPECT_EQ(match1.length, 2);
    EXPECT_STR_EQ(match1.data, match1.length, "ab");

    // Second step: now match "cd" in "cd" -> remainder ""
    char buf2[64] = "cd";
    cre2_string_t text2;
    text2.data = buf2;
    text2.length = 2;
    cre2_string_t match2;
    int ret2 = cre2_partial_match("cd", &text2, &match2, 1);
    EXPECT_EQ(ret2, 1);
    EXPECT_EQ(text2.length, 0); // empty remainder
    // Remaining could be an empty string; ensure length == 0
    EXPECT_EQ(text2.length, 0);
    // Capture for the second match
    EXPECT_EQ(match2.length, 2);
    EXPECT_STR_EQ(match2.data, match2.length, "cd");
}

// Test 4: Edge-case with empty input length (text.length == 0) should not crash.
// Expect: return 0 and input remains empty.
void test_cre2_partial_match_empty_input()
{
    char buf[16] = "";
    cre2_string_t text;
    text.data = buf;
    text.length = 0;

    cre2_string_t match;
    int ret = cre2_partial_match("a*", &text, &match, 1); // pattern that could match empty string

    // Depending on implementation, empty input might still match, but to be safe we just ensure no crash.
    // We check that we either get a valid result or 0; both are acceptable here. We'll assert non-negative return.
    EXPECT_TRUE(ret >= 0);
}

// Entry point
int main()
{
    std::cout << "Running tests for cre2_partial_match wrapper...\n";

    test_cre2_partial_match_basic();
    test_cre2_partial_match_no_match();
    test_cre2_partial_match_sequential_mutation();
    test_cre2_partial_match_empty_input();

    if (g_failures == 0) {
        std::cout << "All CRE2 partial_match tests PASSED.\n";
    } else {
        std::cout << g_failures << " CRE2 partial_match test(s) FAILED.\n";
    }

    return g_failures;
}