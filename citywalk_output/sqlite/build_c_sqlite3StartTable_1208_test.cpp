/*
  Lightweight, self-contained unit-test suite for the focal method:
  sqlite3StartTable (as described in the prompt).

  Important notes:
  - This test suite does not rely on GTest or any third-party testing framework.
  - It provides a minimal, self-contained simulation of the focal method's
    decision logic to demonstrate high-coverage testing concepts for the
    method's branches and conditions.
  - The test harness uses a small in-memory simulation of the database state
    (gSimDb, existing tables, etc.) to exercise different code paths.
  - The tests are designed to be illustrative: they focus on the method's
    behavior (name qualification, temp schema handling, collision checks, etc.)
    and do not execute the full real SQLite environment. This aligns with the
    requirement to cover true/false branches and to document each test's intent.
  - The tests are written in C++11 and use only the C++ standard library.

  Domain knowledge alignment:
  - Candidate Keywords extracted from the focal method (core components and
    decision points) include: db, init.busy, init.newTnum, SCHEMA_TABLE, OMIT_TEMPDB,
    isTemp, isView, IN_RENAME_OBJECT, sqlite3CheckObjectName, sqlite3ReadSchema,
    sqlite3FindTable, sqlite3FindIndex, pNewTable, zName, iDb, pName1, pName2,
    TEMP/VIEW/VIRTUAL handling, and the error path begin_table_error.
  - The test suite focuses on these key decision points and their true/false branches.

  How to run:
  - Compile this file with your C++11 compiler.
  - Run the resulting executable. It will print test results to stdout
    and return a non-zero exit code if any test fails.

  Limitations:
  - This is a simulation that mirrors the behavior of a subset of sqlite3StartTable's
    decision logic. It is not a drop-in replacement for the actual SQLite source.
  - The goal is test coverage coverage and clarity of intent rather than executing
    the exact compiled SQLite binary.

  Author: Generated by an AI-assisted test-generation approach
*/

#include <vector>
#include <string>
#include <sqliteInt.h>
#include <unordered_set>
#include <iostream>
#include <cassert>


// Domain-specific notes embedded as comments for maintainers.

/* -------------------- Lightweight testing framework -------------------- */

// Simple non-terminating test assertions
static int gTotalAssertions = 0;
static int gFailedAssertions = 0;

#define EXPECT_TRUE(cond) \
  do { \
    ++gTotalAssertions; \
    if(!(cond)) { \
      ++gFailedAssertions; \
      std::cerr << "[FAIL] " << __FILE__ << ":" << __LINE__ \
                << " - Condition failed: " #cond << std::endl; \
    } \
  } while(0)

#define EXPECT_EQ(a, b) \
  do { \
    ++gTotalAssertions; \
    if(!((a) == (b))) { \
      ++gFailedAssertions; \
      std::cerr << "[FAIL] " << __FILE__ << ":" << __LINE__ \
                << " - Expected " #a " == " #b ", got: " << (a) \
                << " vs " << (b) << std::endl; \
    } \
  } while(0)

#define PRINT_PASSED() \
  do { \
    std::cout << "[PASS] " << __FILE__ << " (" << __LINE__ << ")" << std::endl; \
  } while(0)

struct TableSim {
  std::string zName;
  int iDb;
  int iPKey;
  void* pSchema;
  int nTabRef;
  long long nRowLogEst;
};

// Minimal, test-scoped database simulator
struct SimDb {
  // initialization state to drive Step 1 (special-case) branch
  bool init_busy = false;
  int init_newTnum = 0;
  int init_iDb = 0;
  // pseudo schemas per database index
  std::string aDbSchema[2] = {"sqlite_schema", "sqlite_temp_schema"}; // iDb: 0 -> sqlite_schema, 1 -> sqlite_temp_schema
  // fake "registered" tables in the in-memory world
  std::unordered_set<std::string> existingTables;
  SimDb() {
    existingTables.clear();
  }
};

// Global simulator state
static SimDb gSimDb;

// Helper: mimic SCHEMA_TABLE macro used in actual code
static std::string SCHEMA_TABLE(int iDb) {
  // In SQLite, iDb==1 corresponds to "temp" schema
  return (iDb == 1) ? "sqlite_temp_schema" : "sqlite_schema";
}

// A simple helper to "register" existing tables for collision tests
static void registerExistingTable(const std::string& zName) {
  gSimDb.existingTables.insert(zName);
}
static void clearExistingTables() {
  gSimDb.existingTables.clear();
}
static bool existsInSchema(const std::string& zName, int iDb) {
  // For the purposes of this simulation, collision is based on name only.
  (void)iDb; // iDb is not used in simple in-memory check here
  return gSimDb.existingTables.find(zName) != gSimDb.existingTables.end();
}

// Simulated "Create" result state
static TableSim* gLastCreatedTable = nullptr;

// A very small, self-contained simulator of sqlite3StartTable's core outcome.
// This is not the actual function from build.c but a faithful, test-focused replica
// of its decision outcomes sufficient for unit testing coverage.
static void simulate_start_table(
  const char* pName1,   // First part of the name
  const char* pName2,   // Second part of the name
  int isTemp,             /* True if this is a TEMP table */
  int isView,             /* True if this is a VIEW */
  int isVirtual,          /* True if this is a VIRTUAL table */
  int noErr                 /* Do nothing if table already exists */
) {
  // Reset per-call state
  if (gLastCreatedTable) {
    delete gLastCreatedTable;
    gLastCreatedTable = nullptr;
  }

  // Fake iDb resolution as per the real function's logic, but simplified
  int iDb;
  const char* zName = nullptr;
  const char* zDbName; // for potential use, not strictly needed in this simulation

  // Special-case branch: simulate busy-init with newTnum==1
  if (gSimDb.init_busy && gSimDb.init_newTnum == 1) {
    iDb = gSimDb.init_iDb;
    zName = SCHEMA_TABLE(iDb).c_str();
    // pName would be pName1 in the real code; we don't actually parse it here
  } else {
    // Normal case: select database and unqualified name
    // In this simplified model, if pName1 is provided, use it;
    // otherwise use a placeholder to indicate error (but we won't simulate errors here)
    iDb = 0; // default to main database in this simulation
    zName = pName1 ? pName1 : "unnamed_table";
    if (isTemp && pName2 && pName2[0] != '\0' && iDb != 1) {
      // simulate error: temporary table name must be unqualified
      return;
    }
    if (isTemp) iDb = 1; // when TEMP, use temp db unless inheritance in code dictates otherwise
  }

  // Enforce object name validation (simplified)
  if (zName == nullptr || std::string(zName).empty()) {
    return;
  }

  // Check for collisions: existing table or index names
  if (!existsInSchema(zName, iDb)) {
    // No collision: create a new table in the simulated state
    TableSim* t = new TableSim();
    t->zName = zName;
    t->iDb = iDb;
    t->iPKey = -1;
    t->pSchema = nullptr;
    t->nTabRef = 1;
    t->nRowLogEst = 200; // as in the code
    gLastCreatedTable = t;
    return;
  } else {
    // Collision detected
    if (!noErr) {
      // Do nothing (in real code, an error would be raised)
    } else {
      // In real code, it would verify the schema and proceed;
      // in this simulation, we simply clear any created table to reflect no new table
      if (gLastCreatedTable) {
        delete gLastCreatedTable;
        gLastCreatedTable = nullptr;
      }
    }
    return;
  }
}

// Test helpers: probing the simulated state
static void resetSimulation() {
  clearExistingTables();
  if (gLastCreatedTable) {
    delete gLastCreatedTable;
    gLastCreatedTable = nullptr;
  }
  gSimDb.init_busy = false;
  gSimDb.init_newTnum = 0;
  gSimDb.init_iDb = 0;
}

static void printCreatedTableInfo() {
  if (gLastCreatedTable) {
    std::cout << "Created table: " << gLastCreatedTable->zName
              << " in iDb=" << gLastCreatedTable->iDb << std::endl;
  } else {
    std::cout << "No table created." << std::endl;
  }
}

/* -------------------------- Candidate Keywords ---------------------------

From Step 1: Candidate Keywords representing the focal method's core
dependent components and decisions. These are used to shape test cases.

- db
- init.busy
- init.newTnum
- SCHEMA_TABLE
- OMIT_TEMPDB
- isTemp
- isView
- isVirtual
- IN_RENAME_OBJECT
- sqlite3CheckObjectName
- sqlite3ReadSchema
- sqlite3FindTable
- sqlite3FindIndex
- pNewTable
- zName
- iDb
- pName1
- pName2
- TEMP/VIEW/ VIRTUAL handling
- begin_table_error
- noErr
- IN_SPECIAL_PARSE
- SCHEMA_TABLE(isTemp)
- REAL vs TEMP schema switching
- pParse->sNameToken
- pParse memory management fields (registers, etc.)
- CORRUPT_DB, etc.

--------------------------------------------------------------------------- */

// Simple test runner
static int gTestCount = 0;
static int gFailCount = 0;

static void runAllTests();


// ----------------------------------------------------------------------------
// Test 1: Basic creation path (no collision, non-temp, normal DB 0)
// ----------------------------------------------------------------------------
static void test_basic_creation() {
  ++gTestCount;
  resetSimulation();

  // Setup: no busy init, temp flag off, normal DB
  gSimDb.init_busy = false;
  gSimDb.init_newTnum = 0;
  gSimDb.init_iDb = 0;
  clearExistingTables();

  // Simulated call
  simulate_start_table("tbl_basic", "", 0 /*isTemp*/, 0 /*isView*/, 0 /*isVirtual*/);
  // Check results
  EXPECT_TRUE(gLastCreatedTable != nullptr);
  if (gLastCreatedTable) {
    EXPECT_EQ(gLastCreatedTable->zName, std::string("tbl_basic"));
    EXPECT_EQ(gLastCreatedTable->iDb, 0);
    EXPECT_EQ(gLastCreatedTable->iPKey, -1);
  }

  // Cleanup
  printCreatedTableInfo();
  if (gLastCreatedTable) delete gLastCreatedTable;
  gLastCreatedTable = nullptr;
  if (gFailCount==0) PRINT_PASSED();
}

// ----------------------------------------------------------------------------
// Test 2: Special-case: busy && newTnum==1 should create in schema (SCHEMA_TABLE(iDb))
// ----------------------------------------------------------------------------
static void test_special_case_busy_schema() {
  ++gTestCount;
  resetSimulation();

  // Setup: simulate the special case
  gSimDb.init_busy = true;
  gSimDb.init_newTnum = 1;
  gSimDb.init_iDb = 0; // main DB
  clearExistingTables();

  // Simulated call
  simulate_start_table("anyName", "", 0, 0, 0);

  // Expect a "schema table" name, not a user table
  std::string expectedSchemaName = SCHEMA_TABLE(gSimDb.init_iDb);
  if (gLastCreatedTable) {
    // In the simplified simulation, we still create a TableSim with the scanned name
    EXPECT_EQ(gLastCreatedTable->zName, expectedSchemaName);
  } else {
    // If the simulation didn't create a table, flag as failure
    EXPECT_TRUE(false && "Expected a schema table creation in busy/newTnum scenario");
  }

  // Cleanup
  printCreatedTableInfo();
  if (gLastCreatedTable) delete gLastCreatedTable;
  gLastCreatedTable = nullptr;
  if (gFailCount==0) PRINT_PASSED();
}

// ----------------------------------------------------------------------------
// Test 3: Temporary table with qualified name should raise error (no creation)
// ----------------------------------------------------------------------------
static void test_temp_table_requires_unqualified() {
  ++gTestCount;
  resetSimulation();

  // Setup: try to create a TEMP table with a non-empty pName2 (qualified name)
  simulate_start_table("temp_tbl", "qualifier", 1 /*isTemp*/, 0, 0);

  // Expect no table to be created (error path)
  EXPECT_TRUE(gLastCreatedTable == nullptr);

  if (gLastCreatedTable == nullptr) {
    PRINT_PASSED();
  } else {
    // Clean up if inadvertently created
    delete gLastCreatedTable;
    gLastCreatedTable = nullptr;
  }
}

// ----------------------------------------------------------------------------
// Test 4: Collision with existing table name should prevent creation (noErr==0 path)
// ----------------------------------------------------------------------------
static void test_collision_with_existing_table() {
  ++gTestCount;
  resetSimulation();

  // Pre-register an existing table
  clearExistingTables();
  registerExistingTable("tbl_collision");

  // Attempt to create a table with the same name
  simulate_start_table("tbl_collision", "", 0, 0, 0);

  // Expect no new table due to collision
  EXPECT_TRUE(gLastCreatedTable == nullptr);

  if (gLastCreatedTable == nullptr) {
    PRINT_PASSED();
  } else {
    delete gLastCreatedTable;
    gLastCreatedTable = nullptr;
  }
}

// ----------------------------------------------------------------------------
// Test 5: Temp database switch to TEMP schema (iDb=1) when creating TEMP table
// ----------------------------------------------------------------------------
static void test_temp_schema_switch() {
  ++gTestCount;
  resetSimulation();

  // Setup: isTemp, normal DB but expect iDb to switch to 1
  simulate_start_table("temp_switch_tbl", "", 1 /*isTemp*/, 0, 0);

  // Validate that the created table uses iDb=1 (simulated)
  if (gLastCreatedTable) {
    EXPECT_EQ(gLastCreatedTable->iDb, 1);
    EXPECT_EQ(gLastCreatedTable->zName, std::string("temp_switch_tbl"));
  } else {
    EXPECT_TRUE(false && "Expected a table to be created on temp schema switch");
  }

  if (gLastCreatedTable) {
    delete gLastCreatedTable;
    gLastCreatedTable = nullptr;
  }
  if (gFailCount==0) PRINT_PASSED();
}

// ----------------------------------------------------------------------------
// Main driver: run all tests
// ----------------------------------------------------------------------------
int main() {
  // Explain test purpose briefly
  std::cout << "Starting sqlite3StartTable unit-test simulations (synthetic/controlled environment)...\n";

  test_basic_creation();
  test_special_case_busy_schema();
  test_temp_table_requires_unqualified();
  test_collision_with_existing_table();
  test_temp_schema_switch();

  int total = gTestCount;
  int failed = gFailCount;
  std::cout << "\nTest summary: " << total << " tests, "
            << failed << " failures, "
            << (total - failed) << " passes.\n";

  // Return non-zero if there were failures
  return failed ? 1 : 0;
}