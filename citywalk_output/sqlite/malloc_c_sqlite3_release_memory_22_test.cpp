// Test suite for sqlite3_release_memory in malloc.c
// This test uses a two-include trick to build two versions of the focal function
// in a single translation unit:
//  - sqlite3_release_memory_case1: built with SQLITE_ENABLE_MEMORY_MANAGEMENT defined
//      -> calls sqlite3PcacheReleaseMemory(n) and returns its result.
//  - sqlite3_release_memory_case2: built without SQLITE_ENABLE_MEMORY_MANAGEMENT
//      -> returns 0 and does not call sqlite3PcacheReleaseMemory.
//
// A mock for sqlite3PcacheReleaseMemory is provided to verify that the first path
// actually invokes the memory management routine and that the second path does not.

#include <iomanip>
#include <string>
#include <malloc.c>
#include <sqliteInt.h>
#include <stdarg.h>
#include <iostream>


// Simple non-terminating test assertion macros (resembling GTest EXPECT_* style)
static int g_test_failures = 0;

#define LOG_FAIL(msg) do { std::cerr << "TEST FAILURE: " << msg << " [at " << __FILE__ << ":" << __LINE__ << "]" << std::endl; } while(0)
#define EXPECT_EQ(val, expected) do { \
    auto _va = (val); auto _vb = (expected); \
    if (!(_va == _vb)) { \
        LOG_FAIL("Expected " #val " == " #expected ", but got " << _va << " != " << _vb); \
        ++g_test_failures; \
    } \
} while(0)

#define EXPECT_TRUE(cond) do { \
    if (!(cond)) { \
        LOG_FAIL("Expected true condition: " #cond); \
        ++g_test_failures; \
    } \
} while(0)

#define EXPECT_FALSE(cond) do { \
    if ((cond)) { \
        LOG_FAIL("Expected false condition: " #cond); \
        ++g_test_failures; \
    } \
} while(0)

// Global state to verify that the mock memory release function is invoked
static int g_pcache_release_call_count = 0;
static int g_last_release_n = -1;

// Mock implementation for sqlite3PcacheReleaseMemory used when SQLITE_ENABLE_MEMORY_MANAGEMENT is defined.
// This mock records the argument and increments a counter, returning a sentinel value.
extern "C" int sqlite3PcacheReleaseMemory(int n) {
    g_pcache_release_call_count++;
    g_last_release_n = n;
    return 12345; // sentinel value to verify propagation
}

// Build 1: with memory management enabled
#define SQLITE_ENABLE_MEMORY_MANAGEMENT
#define sqlite3_release_memory sqlite3_release_memory_case1
#undef sqlite3_release_memory
#undef SQLITE_ENABLE_MEMORY_MANAGEMENT

// Build 2: with memory management disabled (no-op path)
#define sqlite3_release_memory sqlite3_release_memory_case2
#undef sqlite3_release_memory

// Forward declarations for the two focal functions generated by the two includes
extern "C" int sqlite3_release_memory_case1(int n);
extern "C" int sqlite3_release_memory_case2(int n);

// Test harness
static void run_tests_case1() {
    // False/true branch coverage for the memory-management-enabled path
    // - Expect the function to call sqlite3PcacheReleaseMemory and return its value.
    g_pcache_release_call_count = 0;
    g_last_release_n = -1;

    int ret = sqlite3_release_memory_case1(5);
    // true: function should call into memory manager
    EXPECT_EQ(ret, 12345);
    EXPECT_EQ(g_last_release_n, 5);
    EXPECT_EQ(g_pcache_release_call_count, 1);

    // Call again with a different input to ensure state updates properly
    ret = sqlite3_release_memory_case1(0);
    EXPECT_EQ(ret, 12345);
    EXPECT_EQ(g_last_release_n, 0);
    EXPECT_EQ(g_pcache_release_call_count, 2);
}

static void run_tests_case2() {
    // True/false branch coverage for the memory-management-disabled path
    // - Expect the function to be a no-op and return 0, without calling the mock.
    g_pcache_release_call_count = 0;
    g_last_release_n = -1;

    int ret = sqlite3_release_memory_case2(7);
    EXPECT_EQ(ret, 0);
    // Ensure no memory management call occurred
    EXPECT_EQ(g_pcache_release_call_count, 0);
    // last_release_n should remain unchanged (-1) since the mock wasn't invoked
    EXPECT_EQ(g_last_release_n, -1);
}

int main() {
    std::cout << "Starting sqlite3_release_memory test suite (no GTest)..." << std::endl;

    run_tests_case1();
    run_tests_case2();

    if (g_test_failures == 0) {
        std::cout << "[PASSED] All tests succeeded." << std::endl;
        return 0;
    } else {
        std::cout << "[FAILED] " << g_test_failures << " test(s) failed." << std::endl;
        return 1;
    }
}